    
                                С П Р А В К А


    В данной справке освещаются основные аспекты наиболее важных алгоритмов 
внутренней сортировки, с которыми Вы встречались.  (Как обычно, N  означает 
число элементов в массиве).


  1. Обменная сортировка с выбором (метод пузырька)
     Если  изначально  последовательность  упорядочена  по  возрастанию, то
     наименьшее    число    обменов   для   получения   последовательности,
     отсортированной  в  возрастающем  порядке,  равно 0, а максимальное же
     число  обменов  для  получения  последовательности,  отсортированной в
     убывающем  порядке,  равно(n-1)*n/2.  Среднее число обменов составляет
     промежуточное значение (n-1)*n/4. Число сравнений равно минимум (n-1),
     максимум  (n-1)*n/2;  первое  соответствует случаю наилучшего варианта
     числа  обменов,  второе - случаю  наихудшего  варианта.  Среднее число
     сравнений  отклоняется  от  промежуточного  в  большую  сторону.
     Характеризуя  метод  в  целом, можно  утверждать, что  он работает тем 
     эффетивнее, чем правильнее расположены элементы ряда  в  его  исходном
     состоянии.
     Метод не имеет ярко выраженных преимуществ, так как всегда можно найти 
     лучший  способ  сделать  то,  что  он делает; но даже этот метод после 
     соответствующего обобщения оказывается полезным для сортировки с двумя 
     файлами. Следует иметь в виду, что метод пузырька эффективен далеко не 
     всегда,  в  частности,  когда  элементы  ряда изначально расположены в 
     убывающем порядке, этот метод будет работать очень плохо.

  2. Сортировка посредством простого выбора.
     Но чем плох линейный метод и зачем нужен еще какой-то? Представим себе
     такую ситуацию: ряд Mas содержит числа 1, 2, 3 ,..., 78, 80, 79,причем
     именно  в  указанном порядке.  Как видно,  большинство  элементов  уже
     упорядоченно  по  возрастанию значений, за исключением двух последних,
     стоящих "наоборот".
     Много ли нам потребуется времени,чтобы окончательно отсортировать этот
     ряд?  Несомненно,  человек  справится  с  такой  задачей очень быстро:
     заметив, что первые 78 чисел стоят в нужном порядке, он сразу поменяет
     местами 80 и 79.  А как скоро проделает ту же работу алгоритм линейной
     сортировки? Увы,это будет происходить слишком долго. Ведь программа не
     в  состоянии  сообразить,  что  почти  все  элементы  уже  находятся в
     правильных  позициях, и, следовательно,  ей  остается  сделать  совсем
     немного.Вместо этого она добросовестно отыщет наименьшее из всех чисел
     и поместит  его  в  Mas[1],  что будет достигнуто ценой 79 сравнений в
     парах чисел:  1-2, 1-3, ...., 1-78, 1-80, 1-79. Затем  элемент  Mas[1]
     будет исключен из дальнейшего рассмотрения,  и  повторится аналогичная
     серия  сравнений  числа  2  со  всеми остальными,  что даст  второе по
     величине число и т.д. Действуя подобным образом, программа совершит 79
     проходов  по  элементам ряда,  выполнив  при  этом около 3000 операций
     сравнения.  Впрочем это еще не самый  убедительный  пример.  Как будет
     вести себя алгоритм линейной сортировки,когда в исходном состоянии все
     элементы были расставлены в правильном порядке?  Ему понадобится точно
     такое же число проходов и сравнений.  Довольно курьезная ситуация: ряд
     полностью отсортирован, но, чтобы убедиться в этом, нужно  осуществить
     более 3000 сравнений!  Таким образом,  независимо  от  первоначального
     расположения   элементов  ряда  для  их  сортировки  линейным  методом
     требуется всегда одно и то же число сравнений.
     Из этого,  однако,  не следует,  что  при любом первоначальном порядке
     элементов процесс будет продолжаться одно и то же время. На самом деле
     оно будет тем меньше,  чем лучше была исходная упорядоченность за счет
     уменьшения числа наиболее времяемких операций - перестановок.
  3. Сортировка простыми вставками
     Алгоритм    наиболее    прост   для   программирования,   не   требует 
     дополнительного пространства и вполне эффективен при малых  N (скажем, 
     при N < 25).  При  больших N он становится невыносимо медленным,  если 
     только исходные данные не окажутся сразу почти упорядоченными.
     Этот  алгоритм  является устойчивым алгоритмом. Если число сравнений и
     перемещений разделить на минимальное число сравнений (n-1), мы получим
     некоторую характеристику алгоритма, называемую "числом инверсий".  Для
     случая,  когда  последовательность  с  самого  начала отсортирована  в
     возрастающем  порядке,  число инверсий  минимально и равно 0.  Если  с
     самого  начала  последовательность  отсортирована в убывающем порядке,
     число  инверсии  максимально  и  равно  (n -1)* n /2.  Число  инверсий
     представляет  собой  число  случаев,  когда  Xk  меньше  элементов  из
     последовательности х1, ..., Xk-1 для k = (2,..., n).
  4. Сортировка с убывающим шагом (метод Шелла).
     Для алгоритма сортировки,  который каждый раз перемещает запись только
     на   одну   позицию,  среднее  время  работы  будет  в  лучшем  случае
     пропорционально  N*N,  потому что в процессе  сортировки каждая запись
     должна  пройти в среднем через N/3 позиций.  Поэтому,  если  мы  хотим
     получить метод, существенно превосходящий по скорости простые вставки,
     то необходим некоторый механизм,  с помощью  которого  записи могли бы
     перемещаться большими скачками,  а не короткими шажками.  Однако метод
     простых  вставок  дает  хороший  эффект  либо  в  случае  малого числа
     элементов  сортируемой  последовательности,  либо  в случае небольшого
     числа перемещений, выполняемых при сортировке.
     Алгоритм   (метод Шелла)   так  же  довольно  просто  программируется, 
     использует минимальный объем памяти и довольно эффективен при умеренно 
     больших N (скажем, при N < 1000).
  5. Обменная сортировка с разделением (метод Хоара).
     Метод  Хоара,  широко  известный  как  быстрая  сортировка.  Алгоритм, 
     вероятно самый полезный, универсальный алгоритм внутренней сортировки, 
     поскольку он требует очень мало памяти  и  опережает своих конкурентов 
     по  среднему  времени  выполнения на большинстве вычислительных машин. 
     Однако  в  наихудшем случае он может работать очень медленно. Поэтому, 
     если  вероятность  неслучайных  данных  достаточно велика,  приходится 
     тщательно выбирать разделяющий элемент.
     1)   Выбираем  центральный  элемент  массива  А  и  записываем  его  в
     переменную  В.   Затем  элементы  массива  просматриваются  поочередно 
     слева - направо и справа - налево.  При движении  слева - направо ищем
     элемент А[i],  который  будет  больше  или  равен В,  и запоминаем его
     позицию. При движении справа - налево ищем элемент A[j], который будет
     меньше или равен В, и также запоминаем его позицию. Найденные элементы
     меняем местами и продолжаем встречный поиск по указанным условиям.
     Найденные  элементы  меняем  местами  и  так  далее пока при очередной
     итерации  поиска  встречные  индексы i и j не пересекутся. После этого
     первый  этап  считается  законченным,  после  чего  элементы исходного
     массива окажутся разделенными на две части относительно значения В -
     все элементы, которые меньше или равны В, будут располагаться слева от
     границы пересечения индексов i и j, а все элементы, которые больше или
     равны  В,  будут  располагаться  справа  от  границы.  Таким  образом,
     относительно значения В массив получается отсортированным, но левая и
     правая его части еще не упорядочены.
     2)  На  втором  этапе  повторяются  действия первого этапа для левой и
     правой  частей массива в отдельности.  В  результате  массив  окажется
     разбитым  уже  на четыре непересекающиеся по сортировке части, которые
     можно  упорядочивать  по  отдельности.  На третьем  этапе  повторяются
     действия  первого  этапа  в отдельности для каждой из четырех частей и
     так далее,  пока  длина  сортируемых  частей  не  станет равной одному
     элементу и, следовательно, все элементы массива будут уже упорядочены.
     Перефразируем  описанный  алгоритм  для  того, чтобы яснее понять суть 
     метода:
     Среди N значений,  которые  надо отсортировать,  мы выбираем значение,
     называемое опорным элементом.  В  самом начале этот выбор производится
     делением массива пополам.
     Затем  в  начало  массива помещаем все элементы, меньшие ведущего, а в 
     конец массива - все остальные.
     На  каждой  из  полученных  подпоследовательностей  мы  повторяем  эту 
     операцию, до тех пор пока  не получим подпоследовательности, состоящие 
     из одного или двух элементов.
     Таким образом, массив отсортирован.


  Временные    характеристики    приведенных   методов   можно  практически 
получить на данном типе машины.


