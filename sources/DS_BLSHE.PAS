unit DS_Blshem;
interface
  procedure Block_Shema(zad:byte);{Рисование блоксхемы, анализа метода, Pascal программы}
implementation
uses crt,graph,DS_Ramks,DS_Mouse,DS_Buton,DS_Photo;
{---Процедура рисования блоксхемы, анализа метода, Pascal программы---------}
   procedure Block_Shema(zad:byte);

      procedure Block_Shema_1;
      begin
           setcolor(15);
           OutTextXY(120,10,'Обменная сортировка с выбором (метод пузырька)');

           {setcolor(0);

           outtextxy (510,42,'Начало');
           line      (510,35,555,35);
           line      (510,55,555,55);
           arc       (510,45,430,270,10);
           arc       (555,45,250,450,10);
           line      (532,55,532,65);
           line      (527,60,532,65);
           line      (537,60,532,65);

           outtextxy (518,72,'I:=2');
           rectangle (500,65,565,85);
           line      (532,85,532,95);
           line      (527,90,532,95);
           line      (537,90,532,95);

           outtextxy (518,102,'J:=N');
           rectangle (500,95,565,115);
           line      (532,115,532,125);
           line      (527,120,532,125);
           line      (537,120,532,125);

           outtextxy (475,142,'MAS[J-1]>MAS[j]');
           outtextxy (435,137,'НЕТ');
           outtextxy (538,165,'ДА');
           line      (457,145,532,125);
           line      (457,145,532,165);
           line      (609,145,532,125);
           line      (609,145,532,165);

           line      (532,165,532,175);
           line      (527,170,532,175);
           line      (537,170,532,175);

           outtextxy (471,182,'TMP:=MAS[J-1]');
           outtextxy (471,192,'MAS[J-1]:=MAS[J]');
           outtextxy (471,202,'MAS[J]:=TMP');
           rectangle (467,175,600,215);
           line      (532,215,532,225);
           line      (527,220,532,225);
           line      (537,220,532,225);

           outtextxy (508,232,'J:=J-1');
           rectangle (500,225,565,245);
           line      (532,245,532,255);
           line      (527,250,532,255);
           line      (537,250,532,255);

           outtextxy (513,262,'J = I');
           outtextxy (575,257,'НЕТ');
           outtextxy (538,275,'ДА');
           line      (490,265,532,255);
           line      (490,265,532,275);
           line      (574,265,532,255);
           line      (574,265,532,275);
           line      (532,275,532,285);
           line      (527,280,532,285);
           line      (537,280,532,285);

           outtextxy (508,292,'I:=I+1');
           rectangle (500,285,565,305);
           line      (532,305,532,315);
           line      (527,310,532,315);
           line      (537,310,532,315);

           outtextxy (513,322,'I = N');
           outtextxy (468,317,'НЕТ');
           outtextxy (538,335,'ДА');
           line      (490,325,532,315);
           line      (490,325,532,335);
           line      (574,325,532,315);
           line      (574,325,532,335);
           line      (532,335,532,345);
           line      (527,340,532,345);
           line      (537,340,532,345);

           outtextxy (512,352,'Конец');
           line      (510,345,555,345);
           line      (510,365,555,365);
           arc       (510,355,430,270,10);
           arc       (555,355,250,450,10);

           line      (460,145,435,145);
           line      (435,145,435,220);
           line      (435,220,532,220);
           line      (532,220,525,217);
           line      (532,220,525,223);

           line      (425,325,494,325);
           line      (425,325,425,90);
           line      (425,90,532,90);
           line      (532,90,525,87);
           line      (532,90,525,93);

           line      (570,265,620,265);
           line      (620,265,620,120);
           line      (620,120,532,120);
           line      (532,120,539,117);
           line      (532,120,539,123);}


           Pcx_Photo('.\DS_data\img\ds_bls_1.pcx',433,28);


           Ramka_4(19,51,418,190,'Принцип метода');
           Setcolor(0);
           OutTextXY(26,57, '       Cправа налево поочередно сравниваются два');
           OutTextXY(26,67, 'соседних  элемента, и если их взаиморасположение');
           OutTextXY(26,77, 'не соответствует  заданному  условию упорядочен-');
           OutTextXY(26,87, 'ности то они меняются местами. Далее берутся два');
           OutTextXY(26,97, 'следующих  соседних  элемента  и  так  далее  до');
           OutTextXY(26,107,'начала массива.');
           OutTextXY(26,117,'       После  одного  такого  прохода  на первой');
           OutTextXY(26,127,'позиции   массива   будет   стоять   минимальный');
           OutTextXY(26,137,'элемент ("всплыл"  первый  "пузырек"). Поскольку');
           OutTextXY(26,147,'минимальный  элемент  уже  стоит на своей первой');
           OutTextXY(26,157,'позиции, то второй проход обменов выполняется до');
           OutTextXY(26,167,'2-го элемента.');
           OutTextXY(26,177,'       И так далее. Всего требуется N-1 проход.');

           Ramka_4(19,213,418,275,'Краткий анализ метода');
           Setcolor(0);
           OutTextXY(26,216,'     Метод не имеет ярко выраженных преимуществ,');
           OutTextXY(26,226,'так   как   всегда  можно  найти  лучший  способ');
           OutTextXY(26,236,'сделать  то,  что он делает;  но даже этот метод');
           OutTextXY(26,246,'после  соответствующего  обобщения   оказывается');
           OutTextXY(26,256,'полезным  для  сортировки  с  двумя  лентами.');

           Ramka_4(19,298,418,428,'Пример процедуры сортировки методом "пузырька"');
           SetColor(0);
           OutTextXY(26,302,'Procedure BubleSort (var MAS:Array of integer);');
           OutTextXY(26,312,'Var I,J,TMP:integer;');
           OutTextXY(26,322,'    Begin');
           OutTextXY(26,332,'         For I:=2 to N do');
           OutTextXY(26,342,'             For J:=N DownTo I do');
           OutTextXY(26,352,'                 If MAS[J-1] > MAS[J]');
           OutTextXY(26,362,'                    Then');
           OutTextXY(26,372,'                         Begin');
           OutTextXY(26,382,'                               TMP:=MAS[J-1];');
           OutTextXY(26,392,'                               MAS[J-1]:=MAS[J];');
           OutTextXY(26,402,'                               MAS[J]:=TMP;');
           OutTextXY(26,409,'                         End;');
           OutTextXY(26,415,'    End;');

           Ramka_2(423,370,633,428);
           Setcolor(0);
           OutTextXY(426,374,'         __________');
           OutTextXY(426,373,'         Примечание');
           OutTextXY(426,385,' N -Кол-во эл. в массиве');
           OutTextXY(426,395,'MAS-Массив ( Array[1..N] )');
           OutTextXY(426,405,'TMP-Вспомогательная перем.');
           OutTextXY(426,415,'I,J-Используются в циклах');
      end;

      procedure Block_Shema_2;
      begin
           setcolor(15);
           OutTextXY(120,10,'Сортировка посредством простого выбора');

           {setcolor(0);

           outtextxy (510,42,'Начало');
           line      (510,35,555,35);
           line      (510,55,555,55);
           arc       (510,45,430,270,10);
           arc       (555,45,250,450,10);
           line      (532,55,532,65);
           line      (527,60,532,65);
           line      (537,60,532,65);

           outtextxy (518,72,'I:=1');
           rectangle (500,65,565,85);
           line      (532,85,532,95);
           line      (527,90,532,95);
           line      (537,90,532,95);

           outtextxy (487,102,'Min:=MAS[I]');
           outtextxy (487,112,'NMin:=I');
           rectangle (480,95,585,125);
           line      (532,125,532,135);
           line      (527,130,532,135);
           line      (537,130,532,135);

           outtextxy (508,142,'J:=I+1');
           rectangle (500,135,565,155);
           line      (532,155,532,165);
           line      (527,160,532,165);
           line      (537,160,532,165);



           outtextxy (495,176,'MAS[J]<Min');
           outtextxy (455,172,'НЕТ');
           outtextxy (538,195,'ДА');
           line      (477,180,532,165);
           line      (477,180,532,195);
           line      (589,180,532,165);
           line      (589,180,532,195);
           line      (532,195,532,205);
           line      (527,200,532,205);
           line      (537,200,532,205);

           outtextxy (487,212,'Min:=MAS[J]');
           outtextxy (487,222,'NMin:=J');
           rectangle (480,205,585,235);
           line      (532,235,532,245);
           line      (527,240,532,245);
           line      (537,240,532,245);

           outtextxy (508,252,'J:=J+1');
           rectangle (500,245,565,265);
           line      (532,265,532,275);
           line      (527,270,532,275);
           line      (537,270,532,275);

           outtextxy (513,282,'J = N');
           outtextxy (575,277,'НЕТ');
           outtextxy (538,295,'ДА');
           line      (490,285,532,275);
           line      (490,285,532,295);
           line      (574,285,532,275);
           line      (574,285,532,295);
           line      (532,295,532,305);
           line      (527,300,532,305);
           line      (537,300,532,305);

           outtextxy (463,312,'MAS[NMin]:=MAS[I]');
           outtextxy (463,322,'MAS[I]:=Min');
           rectangle (460,305,605,335);
           line      (532,335,532,345);
           line      (527,340,532,345);
           line      (537,340,532,345);

           outtextxy (508,352,'I:=I+1');
           rectangle (500,345,565,365);
           line      (532,365,532,375);
           line      (527,370,532,375);
           line      (537,370,532,375);

           outtextxy (513,382,'I=N-1');
           outtextxy (467,377,'НЕТ');
           outtextxy (538,395,'ДА');
           line      (490,385,532,375);
           line      (490,385,532,395);
           line      (574,385,532,375);
           line      (574,385,532,395);
           line      (532,395,532,405);
           line      (527,400,532,405);
           line      (537,400,532,405);

           outtextxy (512,412,'Конец');
           line      (510,405,555,405);
           line      (510,425,555,425);
           arc       (510,415,430,270,10);
           arc       (555,415,250,450,10);

           line      (480,180,445,180);
           line      (445,180,445,240);
           line      (445,240,532,240);
           line      (532,240,525,237);
           line      (532,240,525,243);

           line      (425,385,494,385);
           line      (425,385,425,90);
           line      (425,90,532,90);
           line      (532,90,525,87);
           line      (532,90,525,93);

           line      (570,285,620,285);
           line      (620,285,620,160);
           line      (620,160,532,160);
           line      (532,160,539,157);
           line      (532,160,539,163);}


           Pcx_Photo('.\DS_data\img\ds_bls_2.pcx',435,28);


           Ramka_4(19,50,418,140,'Принцип метода');
           Setcolor(0);
           OutTextXY(26,55, '       Находим  (выбираем) в массиве  элемент  с');
           OutTextXY(26,65, 'минимальным   значением  на  интервале  от  1-го');
           OutTextXY(26,75, 'элемента до  N-го (последнего) элемента и меняем');
           OutTextXY(26,85, 'его  местами с первым элементом.  На втором шаге');
           OutTextXY(26,95, 'находим  элемент  с  минимальным  значением   на');
           OutTextXY(26,105,'интервале от 2-го до  N-го элемента и меняем его');
           OutTextXY(26,115,'местами со вторым элементом.');
           OutTextXY(26,125,'       И так далее для всех элементов до N-1-го.');

           Ramka_4(19,163,418,213,'Краткий анализ метода');
           Setcolor(0);
           OutTextXY(26,168,'     Алгоритм довольно прост и особенно подходит');
           OutTextXY(26,178,'в случае, когда имеется специальное оборудование');
           OutTextXY(26,188,'для   быстрого   поиска   наименьшего   элемента');
           OutTextXY(26,198,'в списке.');

           Ramka_4(19,237,418,428,'Пример процедуры сортировки простым выбором');
           SetColor(0);
           OutTextXY(26,242,'Procedure SelectionSort(varMAS:Array of integer);');
           OutTextXY(26,252,'Var I,J:integer;       {I,J-Использются в циклах}');
           OutTextXY(26,262,'    Min,NMin:integer;  {Min-Минимальный элемент}');
           OutTextXY(26,272,'    Begin              {Nmin-Номер мин.эл-та}');
           OutTextXY(26,282,'         For I:=1 to N-1 do {N-Кол-во эл. в мас.}');
           OutTextXY(26,292,'            Begin');
           OutTextXY(26,302,'                  Min:=MAS[I];');
           OutTextXY(26,312,'                  NMin:=I;');
           OutTextXY(26,322,'                  For J:=I+1 To N do');
           OutTextXY(26,332,'                      If MAS[J] < Min');
           OutTextXY(26,342,'                         Then');
           OutTextXY(26,352,'                             Begin');
           OutTextXY(26,362,'                                  Min:=MAS[J];');
           OutTextXY(26,372,'                                  NMin:=J;');
           OutTextXY(26,382,'                             End;');
           OutTextXY(26,392,'                  MAS[NMin]:=MAS[I];');
           OutTextXY(26,402,'                  MAS[I]:=Min;');
           OutTextXY(26,409,'            End;');
           OutTextXY(26,418,'    End;');
      end;

      procedure Block_Shema_3;
      begin
           setcolor(15);
           OutTextXY(180,10,'Сортировка простыми вставками');

           {setcolor(0);

           outtextxy (510,34,'Начало');
           line      (510,30,555,30);
           line      (510,44,555,44);
           arc       (510,37,430,265,7);
           arc       (555,37,250,445,7);
           line      (532,45,532,55);
           line      (527,50,532,55);
           line      (537,50,532,55);

           outtextxy (518,62,'I:=2');
           rectangle (500,55,565,75);
           line      (532,75,532,85);
           line      (527,80,532,85);
           line      (537,80,532,85);

           outtextxy (487,92,'TMP:=MAS[I]');
           outtextxy (487,102,'    J:=1');
           rectangle (480,85,585,115);
           line      (532,115,532,125);
           line      (527,120,532,125);
           line      (537,120,532,125);

           outtextxy (495,136,'TMP>MAS[J]');
           outtextxy (590,132,'НЕТ');
           outtextxy (538,155,'ДА');
           line      (477,140,532,125);
           line      (477,140,532,155);
           line      (589,140,532,125);
           line      (589,140,532,155);
           line      (532,155,532,165);
           line      (527,160,532,165);
           line      (537,160,532,165);

           outtextxy (508,172,'J:=J+1');
           rectangle (500,165,565,185);
           line      (532,190,532,200);
           line      (527,195,532,200);
           line      (537,195,532,200);

           line      (465,174,500,174);
           line      (465,174,465,140);
           line      (465,140,477,140);
           line      (472,137,477,140);
           line      (472,143,477,140);

           line      (532,190,615,190);
           line      (615,190,615,140);
           line      (589,140,615,140);

           outtextxy (508,207,'K:=I-1');
           rectangle (500,200,565,220);
           line      (532,220,532,230);
           line      (527,225,532,230);
           line      (537,225,532,230);

           outtextxy (468,237,'MAS[K+1]:=MAS[K]');
           rectangle (460,230,605,250);
           line      (532,250,532,260);
           line      (527,255,532,260);
           line      (537,255,532,260);

           outtextxy (508,267,'K:=K-1');
           rectangle (500,260,565,280);
           line      (532,280,532,290);
           line      (527,285,532,290);
           line      (537,285,532,290);

           outtextxy (513,297,'K > J');
           outtextxy (575,292,'НЕТ');
           outtextxy (538,310,'ДА');
           line      (490,300,532,290);
           line      (490,300,532,310);
           line      (574,300,532,290);
           line      (574,300,532,310);
           line      (532,310,532,320);
           line      (527,315,532,320);
           line      (537,315,532,320);

           outtextxy (488,327,'MAS[J]:=TMP');
           rectangle (480,320,585,340);
           line      (532,340,532,350);
           line      (527,345,532,350);
           line      (537,345,532,350);

           outtextxy (508,357,'I:=I+1');
           rectangle (500,350,565,370);
           line      (532,370,532,380);
           line      (527,375,532,380);
           line      (537,375,532,380);

           outtextxy (513,387,'I > N');
           outtextxy (467,382,'НЕТ');
           outtextxy (538,400,'ДА');
           line      (490,390,532,380);
           line      (490,390,532,400);
           line      (574,390,532,380);
           line      (574,390,532,400);
           line      (532,400,532,410);
           line      (527,405,532,410);
           line      (537,405,532,410);

           outtextxy (512,414,'Конец');
           line      (510,410,555,410);
           line      (510,424,555,424);
           arc       (510,417,430,280,7);
           arc       (555,417,250,460,7);

           line      (570,300,620,300);
           line      (620,300,620,225);
           line      (620,225,532,225);
           line      (532,225,539,222);
           line      (532,225,539,228);

           line      (445,390,494,390);
           line      (445,390,445,80);
           line      (445,80,532,80);
           line      (532,80,525,77);
           line      (532,80,525,83);}

           Pcx_Photo('.\DS_data\img\ds_bls_3.pcx',443,28);


           Ramka_4(13,50,438,150,'Принцип метода');
           Setcolor(0);
           OutTextXY(20,55, '    Массив разделяется на две  части: отортированную');
           OutTextXY(20,65, 'и неотсортированную.  Элементы  из неотсортированной');
           OutTextXY(20,75, 'части   поочередно   выбираются   и   вставляются  в');
           OutTextXY(20,85, 'отсортированную  часть  так, чтобы не нарушить в ней');
           OutTextXY(20,95, 'упорядоченность элементов. В начале работы алгоритма');
           OutTextXY(20,105,'в качестве отсортированной части  массива  принимают');
           OutTextXY(20,115,'только   один   первый   элемент,   а   в   качестве');
           OutTextXY(20,125,'неотсортированной  части - все  остальные  элементы.');
           OutTextXY(20,135,'Таким образом, алгоритм будет сост.  из N-1 прохода.');

           Ramka_4(13,173,438,243,'Краткий анализ метода');
           Setcolor(0);
           OutTextXY(20,178,'    Алгоритм наиболее прост для программирования, не');
           OutTextXY(20,188,'требует   дополнительного   пространства   и  вполне');
           OutTextXY(20,198,'эффективен  при  малых   N ( скажем,  при  N < 50 ).');
           OutTextXY(20,208,'    При   больших   N   он   становится   невыносимо');
           OutTextXY(20,218,'медленным, если только исходные данные  не  окажутся');
           OutTextXY(20,228,'сразу почти упорядоченными.');

           Ramka_4(13,267,438,428,'Пример процедуры сортировки простыми вставками');
           SetColor(0);
           OutTextXY(20,273,'Procedure InsertionSort (var MAS:Array of integer);');
           OutTextXY(20,283,'Var I,J,K:byte;  {I,J,K-Использются в циклах}');
           OutTextXY(20,293,'    TMP:integer; {TMP-Для временного хранения эл-тa}');
           OutTextXY(20,303,'    Begin              ');
           OutTextXY(20,313,'         For I:=2 to N do      {N-Кол-во эл. в мас.}');
           OutTextXY(20,323,'            Begin');
           OutTextXY(20,333,'                  TMP:=MAS[I];');
           OutTextXY(20,343,'                  J:=1;');
           OutTextXY(20,353,'                  While TMP > MAS[J] do');
           OutTextXY(20,363,'                        J:=J+1;');
           OutTextXY(20,373,'                  For K:=I-1 DownTo J do');
           OutTextXY(20,383,'                      MAS[K+1]:=MAS[K];');
           OutTextXY(20,393,'                  MAS[J]:=TMP;');
           OutTextXY(20,403,'            End; ');
           OutTextXY(20,413,'    End;');
      end;







      procedure Block_Shema_4;
      begin
           setcolor(15);
           OutTextXY(130,10,'Сортировка с убывающим шагом (метод Шелла)');


           Pcx_Photo('.\DS_data\img\ds_bls_4.pcx',433,28);


           Ramka_4(19,30+50,418,260+30,'Принцип метода');
           Setcolor(0);
           OutTextXY(26,55+30, '       Алгоритм сортировки с убывающим шагом был');
           OutTextXY(26,65+30, 'придуман в 1959 году Дональдом Л. Шеллом.');
           OutTextXY(26,75+30, '       Сортировка Шелла является перестановочной');
           OutTextXY(26,85+30, 'сортировкой.   Это   означает,   что  сортировка');
           OutTextXY(26,95+30, 'производится перестановкой  пар чисел в массиве,');
           OutTextXY(26,105+30,'до  тех  пор,  пока   он   не   будет  полностью');
           OutTextXY(26,115+30,'отсортирован.');
           OutTextXY(26,125+30,'       При   любой   сортировке   объект   имеет');
           OutTextXY(26,135+30,'начальное  и  конечное  положения,  а в процессе');
           OutTextXY(26,145+30,'сортировки он перемещается из одного положения в');
           OutTextXY(26,155+30,'другое.  В  простейших вариантах перестановочных');
           OutTextXY(26,165+30,'сортировок  объекты  перемещаются  за  один такт');
           OutTextXY(26,175+30,'только  на  одну  позицию. Метод Шелла позволяет');
           OutTextXY(26,185+30,'ускорить сортировку,  перемещая  объекты сначала');
           OutTextXY(26,195+30,'на   большие   расстояния,  а  затем   по   мере');
           OutTextXY(26,205+30,'приближения к пункту назначения все на меньшие и');
           OutTextXY(26,215+30,'меньшие.   Первичное   перемещение  делается  на');
           OutTextXY(26,225+30,'половину   длины   массива,  а   все   повторные');
           OutTextXY(26,235+30,'перемещения  уменьшаются  вдвое  по  сравнению с');
           OutTextXY(26,245+30,'предыдущим.');






           Ramka_4(19,280+60,418,330+60,'Краткий анализ метода');
           Setcolor(0);
           OutTextXY(26,285+60,'     Алгоритм  довольно  просто программируется,');
           OutTextXY(26,295+60,'использует минимальный объем памяти  и  довольно');
           OutTextXY(26,305+60,'эффективен при умеренно большом количестве чисел');
           OutTextXY(26,315+60,'( скажем, при N<=1000 ).');


      end;






      procedure Block_Shema_5;
      begin
           Setcolor(15);
           OutTextXY(120,10,'Обменная сортировка с разделением (метод Хоара)');

           setcolor(0);

           Ramka_4(13,50,628,280,'Принцип метода');
           Setcolor(0);
           OutTextXY(20,55,  '1.Выбираем центральный элемент массива Massiv и записываем его в переменную ');
           OutTextXY(20,65,  '  В.  Затем  элементы  массива  просматриваются  поочередно слева-направо и ');
           OutTextXY(20,75,  '  справа-налево. При движении слева-направо ищем элемент Massiv[i], который ');
           OutTextXY(20,85,  '  будет  больше  или  равен  В,  и  запоминаем  его  позицию. При  движении ');
           OutTextXY(20,95,  '  справа-налево ищем элемент Massiv[j], который будете меньше или равен  В, ');
           OutTextXY(20,105, '  и  также  запоминаем  его  позицию.  Найденные  элементы меняем местами и ');
           OutTextXY(20,115, '  продолжаем  встречный  поиск  по  указанным  ycловиям. Найденные элементы ');
           OutTextXY(20,125, '  меняем местами и так далее пока при очередной  итерации  поиска встречные ');
           OutTextXY(20,135, '  индексы  i  и  j  не  пересекутся.  После  этого  первый  этап  считается ');
           OutTextXY(20,145, '  законченным,  после чего элементы исходного массива окажутся разделенными ');
           OutTextXY(20,155, '  на две части относительно значения В - все  элементы,  которые меньше или ');
           OutTextXY(20,165, '  равны В, будут располагаться слева от границы пересечения индексов i и j, ');
           OutTextXY(20,175, '  а все элементы, которые больше или равны  В,  будут  располагаться справа ');
           OutTextXY(20,185, '  от  границы.  Таким образом,  относительно значения  В  массив получается ');
           OutTextXY(20,195, '  отсортированным, но левая и правая его части еще не упорядочены.');
           OutTextXY(20,205, '2.На  втором  этапе  повторяются действия  первого этапа для левой и правой ');
           OutTextXY(20,215, '  частей массива в отдельности.  В  результате массив окажется разбитым уже ');
           OutTextXY(20,225, '  на   четыре   непересекающиеся  по  сортировке   части,   которые   можно ');
           OutTextXY(20,235, '  упорядочивать по  отдельности.  На  третьем  этапе  повторяются  действия ');
           OutTextXY(20,245, '  первого  этапа  в  отдельности  для каждой из четырех частей и так далее, ');
           OutTextXY(20,255, '  пока  длина  сортируемых  частей  не  станет  равной  одному  элементу и, ');
           OutTextXY(20,265, '  следовательно, все элементы массива будут уже упорядочены.');

           Ramka_4(13,302,628,372,'Краткий анализ метода');
           Setcolor(0);
           OutTextXY(20,307, '       Алгоритм, вероятно, самый полезный универсальный алгоритм внутренней ');
           OutTextXY(20,317, 'сортировки,  поскольку  он  требует  очень  мало  памяти и опережает  своих ');
           OutTextXY(20,327, 'конкурентов по среднему времени  выполнения  на  большинстве вычислительных ');
           OutTextXY(20,337, 'машин. Однако в наихудшем случае он может работать очень медленно. Поэтому, ');
           OutTextXY(20,347, 'если вероятность неслучайных данных достаточно велика, приходится тщательно ');
           OutTextXY(20,357, 'выбирать опорный элемент.                                                   ');

           Ramka_4(13,394,628,427,'Краткая историческая справка');
           Setcolor(0);
           OutTextXY(20,401, '       Данный метод,  широко известный как быстрая сортировка, (Quick Sort) ');
           OutTextXY(20,411, ' был разработан в 1962 г. профессором Оксфордского университета К.Хоаром.');
      end;

      procedure Block_Shema_6;
      begin

      end;

   begin
        case zad of
             1:Block_Shema_1;
             2:Block_Shema_2;
             3:Block_Shema_3;
             4:Block_Shema_4;
             5:Block_Shema_5;
             6:Block_Shema_6;
        end;
        Show_Mouse;
        repeat
              vedenie_kursora(10);

        until keypress(10,3);
   end;

end.